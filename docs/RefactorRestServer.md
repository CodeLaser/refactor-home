The REST server
===============

The REST server is a Micronaut application. Its properties may be edited in

The REST API is visible at:

Concepts
--------

The server's REST calls are parameterized by the project only: the server does not make any distinction between clients.

The server is thread-safe in the sense that multiple clients can load the same project, and perform read and write
actions. However, as there is no distinction between clients, all clients operate on the same Git repository, and each
project can be in only one git commit at the same time. Therefore, they must coordinate their write actions, as, for
example, one client's computed plans may be come invalidated by another client's write action. If you want multiple
refactorings to take place independently on the same code base, you should make multiple copies,
and merge the refactorings manually.

The REST calls can be grouped into a number of families of calls:

**Queries** are read-only

**Requests** are refactorings that are carried out immediately unless there are conflicts or warnings.

**Plans** are computed, and can be executed separately.

All modification actions need to be either **accepted** or **rejected**.
The former corresponds to merging that action's branch into the default branch.
Rejection simply moves the server back to the default branch.

Any change is also written to `refactor.log`, a centrally held file that details changes made by the server.


Basic flow
----------

Start by loading your project using `/project/load`.
You can set the initial commit (by providing the commit hash) as a parameter.

This call will kick off project parsing and analysis in the background. Most queries will be blocked (a call will return
HTTP status 423, LOCKED) while this takes place.

Once the project has been analyzed, queries will be accepted.

The resulting `Response` object of a rename request, for example `/request/renameLv`, contains

* conflicts and warnings
* source diffs: a report on what has changed
* a run identifier

Use this run identifier to accept the changes: `/run/accept/{project}/{run id}`.
This will switch the server back to the default branch, and merge in the changes made by the rename request.

Alternatively, you can reject the changes using `/run/reject/{project name}/{run id}`.
This simply moves the server back to the default branch.

When doing a lot of testing, you can reset using `/run/reset/{project name}/{run id}`. This call removes the rename
request's branch so that the branch name can be reused over and over again, switches the server back to the commit
before the request's action, and cleans up any lingering changes (using `git reset` and `git restore`).


File system layout
------------------

In the `projects` directory, each project is represented by name.
In a project's directory, you find:

* `compileMain.sh`, `compileTest.sh`: scripts generated by the `copy` plugin to compile the source code
* `copy.bash`: the script that copies all git-registered files from the original location into `git`
* `git`: the Git directory where the copy resides
* `inputConfiguration.json`: the main input file for the server detailing all the project's dependencies
* `junit-platform-console-standalone.jar`: a jar (loaded from some Maven repository) to execute JUnit tests
* `libs`: contains a copy of every external library dependency. Generated by the `copy` plugin. The
  `inputConfiguration.json` file points into this directory.
* `project.properties`: a Java Properties file.
* `runTests.sh`: the script to run the JUnit tests

The most important one here is the `git` directory. Here all the server's actions take place. You can push/pull and
manage branches at your discretion. You can point your IDE to it.

